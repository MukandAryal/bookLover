//
//  shelvesViewController.swift
//  BookLover
//
//  Created by Nitesh Chauhan on 6/5/18.
//  Copyright (c) 2018 iOS Team. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

typealias MyBookShelfPopUp = (_ status: Int, _ oldStaus: Int) -> ()

protocol shelvesDisplayLogic: class
{
    func displayResponse(viewModel: shelves.ViewModel,isPopup :Bool)
    func displayShelfTypeResponse(viewModel: shelves.ViewModel,isPopup :Bool)
    func displayContinueReadResponse(viewModel: shelves.ViewModel,isPopup :Bool)
    func displayHMsegment()
}

class shelvesViewController: BaseViewControllerUser, shelvesDisplayLogic
{
    
    
    var interactor: shelvesBusinessLogic?
    var router: (NSObjectProtocol & shelvesRoutingLogic & shelvesDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = shelvesInteractor()
        let presenter = shelvesPresenter()
        let router = shelvesRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    ///////////////////////////////////////////////////////

    @IBOutlet weak var tabSwipeFrameView: UIView!
    @IBOutlet weak var mainScrollView: UIScrollView!
    @IBOutlet weak var readCollectionView: UICollectionView!
    @IBOutlet weak var wantToCollectionView: UICollectionView!
    @IBOutlet weak var continueCollectionView: UICollectionView!
    
    var segmentedControl = HMSegmentedControl()
    var bookInfoArray = [shelves.ViewModel.CellData]()
    var wantToInfoArray = [shelves.ViewModel.CellData]()
    var continueReadInfoArray = [shelves.ViewModel.CellData]()
    private var lastContentOffset: CGFloat = 0
    var readIndex : Int?
    var wantIndex : Int?
    var continueIndex : Int?
    var bookId: String? = nil

    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        CustomNavigationItems.sharedInstance.setNavigationBarApperrance(onVC: self, withTitle: localizedTextFor(key: ShelvesSceneText.ShelvesSceneTitle.rawValue))
        CustomNavigationItems.sharedInstance.rightBarButton(onVC: self)
        
        if #available(iOS 11.0, *) {
            readCollectionView?.contentInsetAdjustmentBehavior = .always
            wantToCollectionView?.contentInsetAdjustmentBehavior = .always
            continueCollectionView?.contentInsetAdjustmentBehavior = .always
        }
        
        
        let xibName = localizedTextFor(key: ShelvesSceneText.ShelvesSceneCollectionXibName.rawValue)
        
        readCollectionView.register(UINib(nibName: xibName, bundle: nil), forCellWithReuseIdentifier: xibName)
        wantToCollectionView.register(UINib(nibName: xibName, bundle: nil), forCellWithReuseIdentifier: xibName)
        continueCollectionView.register(UINib(nibName: xibName, bundle: nil), forCellWithReuseIdentifier: xibName)
                let req = shelves.Request(shelf_status: 2, openPop: false)
        interactor?.hitShelvesStatusApi(request: req)
        
        addSlideMenuButton()
    }
    
    
    override func viewDidLayoutSubviews() {
        self.view.backgroundColor = appBackGroundColor
    }
    
    
    
    // MARK: Do something
    func setupSwipeScrollView() {
        self.mainScrollView.delegate = self;
    }
    
    func setupSegment() {
        
        let viewWidth = Int(self.view.frame.size.width)
        
        // Tying up the segmented control to a scroll view
        self.segmentedControl = HMSegmentedControl(frame: tabSwipeFrameView.frame)
        
        let readBtnTitle = localizedTextFor(key: ShelvesSceneText.ShelvesSceneReadButton.rawValue)
        let wantBtnTitle = localizedTextFor(key: ShelvesSceneText.ShelvesSceneWantToReadButton.rawValue)
        let continueBtnTitle = localizedTextFor(key: ShelvesSceneText.ShelvesSceneContinueReadingButton.rawValue)
        
        self.segmentedControl.sectionTitles = [readBtnTitle, wantBtnTitle, continueBtnTitle]
        
        self.segmentedControl.selectedSegmentIndex = 0
        self.segmentedControl.backgroundColor = appBackGroundColor
        let colorAttribute = [NSAttributedStringKey.foregroundColor: UIColor.gray]
        self.segmentedControl.titleTextAttributes = colorAttribute
        
        let selectedColorAttribute = [NSAttributedStringKey.foregroundColor: UIColor.white]
        self.segmentedControl.selectedTitleTextAttributes = selectedColorAttribute
        self.segmentedControl.selectionIndicatorColor = appThemeColor
        self.segmentedControl.selectionStyle = .fullWidthStripe
        self.segmentedControl.selectionIndicatorLocation = .down
//        self.segmentedControl.segmentWidthStyle = .dynamic
        
        
        weak var weakSelf = self
        segmentedControl.indexChangeBlock = {(_ index: Int) -> Void in
            weakSelf!.mainScrollView.scrollRectToVisible(CGRect(x: (viewWidth * index), y: 0, width: viewWidth, height: Int(self.mainScrollView.bounds.size.height)), animated: true)
            
        }
        self.view.addSubview(self.segmentedControl)
    }
    
    //MARK: --- Response Methods --
    
    func performBookPopUpAction() -> MyBookShelfPopUp {
        
        return { [unowned self] status, oldStatus in
            if status >= 3 {
                return
            }
            else {
                if status == 2 {
                     self.interactor?.hitShelvesStatusApi(request: shelves.Request(shelf_status: oldStatus, openPop: true))
                }else{
                   self.interactor?.hitShelvesStatusApi(request: shelves.Request(shelf_status: oldStatus, openPop: false))
                }
            }
        }
    }
    
    //MARK: --- Response Methods --
    
    func displayResponse(viewModel: shelves.ViewModel,isPopup :Bool)
    {
        displayHMsegment()
        bookInfoArray = viewModel.collectionArray
        readCollectionView.reloadData()
        if isPopup == true {
            // rating view open
            print("Heelloooo>>>",isPopup)
            if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
                
                //if let _ = booksDetail.id {
                    
                   // router?.navigateToRatingView(bookId: "\((booksDetail.id!))")
                router?.navigateToRatingView(bookId: "\((readIndex)!)")
                    // }
                }
                
            }else{
               // CustomAlertController.sharedInstance.showLoginFirstAlert()
            }
        }
    //}
    
    
    func displayHMsegment() {
        setupSegment()
        setupSwipeScrollView()
    }
    
    
    func displayShelfTypeResponse(viewModel: shelves.ViewModel,isPopup :Bool)
    {
        wantToInfoArray = viewModel.collectionArray
        wantToCollectionView.reloadData()
        if isPopup == true {
            // rating view open
            
            if isPopup == true {
                // rating view open
                if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
                    
                    //if let _ = booksDetail.id {
                    
                    // router?.navigateToRatingView(bookId: "\((booksDetail.id!))")
                    router?.navigateToRatingView(bookId: "\((wantIndex)!)")
                    // }
                }
                
            }else{
              //  CustomAlertController.sharedInstance.showLoginFirstAlert()
            }
        }
    }
    
    func displayContinueReadResponse(viewModel: shelves.ViewModel,isPopup :Bool)
    {
        continueReadInfoArray = viewModel.collectionArray
        continueCollectionView.reloadData()
        if isPopup == true {
            // rating view open
            
            if isPopup == true {
                // rating view open
                if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
                    
                    //if let _ = booksDetail.id {
                    
                    // router?.navigateToRatingView(bookId: "\((booksDetail.id!))")
                    router?.navigateToRatingView(bookId: "\((continueIndex)!)")
                    // }
                }
                
            }else{
              //  CustomAlertController.sharedInstance.showLoginFirstAlert()
            }
        }
    }
    
    //MARK: -- Collection Cell Button Action
    
    @objc func actionAllReviews(_ sender: UIButton) {
        
       // var bookId: String? = nil
        if self.segmentedControl.selectedSegmentIndex == 0 {
            bookId = "\((bookInfoArray[sender.tag].bookId)!)"
        } else if self.segmentedControl.selectedSegmentIndex == 1 {
            bookId = "\((wantToInfoArray[sender.tag].bookId)!)"
        } else {
            bookId = "\((continueReadInfoArray[sender.tag].bookId)!)"
        }
        
        if bookId != nil {
            router?.navigateToAllReview(bookId: bookId!)
        }
        //CustomAlertController.sharedInstance.showComingSoonAlert()
    }
    
    @objc func actionReadFavouriteUnfavorite(_ sender: UIButton) {
        
        if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
            
            var param: [String : Any]?
            
            let likeStatus = bookInfoArray[sender.tag].is_favourite == true ? false : true
            
            param = [
                "id":bookInfoArray[sender.tag].id!,
                "user_id":CommonFunctions.sharedInstance.getUserId(),
                "is_favourite":likeStatus]
            
            
            CommonFunctions.sharedInstance.hitFavouriteUnfavouriteApi(withData: param!) { (response) in
                
                if response.code == SuccessCode {
                    let result = response.result as! NSDictionary
                    CustomAlertController.sharedInstance.showSuccessAlert(success: (result["result"] as? String)!)
                    
                    self.bookInfoArray[sender.tag].is_favourite = !self.bookInfoArray[sender.tag].is_favourite
                    
                    self.readCollectionView?.reloadItems(at: [IndexPath.init(row: sender.tag, section: 0)])
                    
                } else {
                    
                    CustomAlertController.sharedInstance.showErrorAlert(error: response.error!)
                }
            }
        } else {
            CustomAlertController.sharedInstance.showLoginFirstAlert()
        }
        
    }
    
    @objc func actionAddToShelves(_ sender: UIButton) {
        
        if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
            
            let data:[String:Any] = ["book_id":bookInfoArray[sender.tag].bookId!,"shelf_status":bookInfoArray[sender.tag].shelf_status!,"is_favourite":bookInfoArray[sender.tag].is_favourite,"isFrom":"MyBooks", "cover_photo":bookInfoArray[sender.tag].cover_photo!, "name":bookInfoArray[sender.tag].name!]
                 readIndex =   bookInfoArray[sender.tag].bookId!
                 print("read",readIndex)
            router?.navigateToBookShelves(withData: data)
        } else {
            CustomAlertController.sharedInstance.showLoginFirstAlert()
        }
    }
    
    
    // wantToCollectionView ACTION
    @objc func actionWantToFavouriteUnfavorite(_ sender: UIButton) {
        
        if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
            
            var param: [String : Any]?
            
            let likeStatus = wantToInfoArray[sender.tag].is_favourite == true ? false : true
            
            param = [
                "id":wantToInfoArray[sender.tag].id,
                "user_id":CommonFunctions.sharedInstance.getUserId(),
                "is_favourite":likeStatus]
            
            
            CommonFunctions.sharedInstance.hitFavouriteUnfavouriteApi(withData: param!) { (response) in
                
                if response.code == SuccessCode {
                    let result = response.result as! NSDictionary
                    CustomAlertController.sharedInstance.showSuccessAlert(success: (result["result"] as? String)!)
                    
                    self.wantToInfoArray[sender.tag].is_favourite = !self.wantToInfoArray[sender.tag].is_favourite
                    
                    self.wantToCollectionView?.reloadItems(at: [IndexPath.init(row: sender.tag, section: 0)])
                    
                } else {
                    
                    CustomAlertController.sharedInstance.showErrorAlert(error: response.error!)
                }
            }
        } else {
            CustomAlertController.sharedInstance.showLoginFirstAlert()
        }
    }
    
    
    @objc func actionWantToAddToShelves(_ sender: UIButton) {
        if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
            let data:[String:Any] =
                [
                    "book_id":wantToInfoArray[sender.tag].bookId!,
                    "shelf_status":wantToInfoArray[sender.tag].shelf_status!,
                    "is_favourite":wantToInfoArray[sender.tag].is_favourite,
                    "isFrom":"MyBooks",
                    "cover_photo":wantToInfoArray[sender.tag].cover_photo!,
                    "name":wantToInfoArray[sender.tag].name!
            ]
              wantIndex =   wantToInfoArray[sender.tag].bookId!
            router?.navigateToBookShelves(withData: data)
        } else {
            CustomAlertController.sharedInstance.showLoginFirstAlert()
        }
    }
    
    //ContinueCollectionView ACTION
    
    
    @objc func actionContinueFavouriteUnfavorite(_ sender: UIButton) {
        
        if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
            
            var param: [String : Any]?
            
            let likeStatus = continueReadInfoArray[sender.tag].is_favourite == true ? false : true
            
            param = [
                "id":continueReadInfoArray[sender.tag].id,
                "user_id":CommonFunctions.sharedInstance.getUserId(),
                "is_favourite":likeStatus]
            
            
            CommonFunctions.sharedInstance.hitFavouriteUnfavouriteApi(withData: param!) { (response) in
                
                if response.code == SuccessCode {
                    let result = response.result as! NSDictionary
                    CustomAlertController.sharedInstance.showSuccessAlert(success: (result["result"] as? String)!)
                    
                    self.continueReadInfoArray[sender.tag].is_favourite = !self.continueReadInfoArray[sender.tag].is_favourite
                    
                    self.continueCollectionView?.reloadItems(at: [IndexPath.init(row: sender.tag, section: 0)])
                    
                } else {
                    
                    CustomAlertController.sharedInstance.showErrorAlert(error: response.error!)
                }
            }
        } else {
            CustomAlertController.sharedInstance.showLoginFirstAlert()
        }
        
    }
    
    
    @objc func actionContinueAddToShelves(_ sender: UIButton) {
        
        if CommonFunctions.sharedInstance.isUserLoggedIn() == true {
            let data:[String:Any] =
                [
                    "book_id":continueReadInfoArray[sender.tag].bookId!,
                    "shelf_status":continueReadInfoArray[sender.tag].shelf_status!,
                    "is_favourite":continueReadInfoArray[sender.tag].is_favourite,
                    "isFrom":"MyBooks",
                    "cover_photo":continueReadInfoArray[sender.tag].cover_photo!,
                    "name":continueReadInfoArray[sender.tag].name!
            ]
            continueIndex = continueReadInfoArray [sender.tag].bookId!
            router?.navigateToBookShelves(withData: data)
        } else {
            CustomAlertController.sharedInstance.showLoginFirstAlert()
        }
    }
    
}



extension shelvesViewController: UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout
{
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        
        if collectionView == readCollectionView {
            if bookInfoArray.count > 0 {
                return CGSize(width: (collectionView.frame.size.width-20)/2, height: (TotalWidth-60)/2*1.7)
            } else {
                return CGSize(width: collectionView.frame.size.width, height: 35)
            }
        }
        else if collectionView == wantToCollectionView {
            if wantToInfoArray.count > 0 {
                return CGSize(width: (collectionView.frame.size.width-20)/2, height: (TotalWidth-60)/2*1.7)
            } else {
                return CGSize(width: collectionView.frame.size.width, height: 35)
            }
        }
        else {
            if continueReadInfoArray.count > 0 {
                return CGSize(width: (collectionView.frame.size.width-20)/2, height: (TotalWidth-60)/2*1.7)
            } else {
                return CGSize(width: collectionView.frame.size.width, height: 35)
            }
        }
        
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        
        if collectionView == readCollectionView {
            if bookInfoArray.count > 0 {
                return bookInfoArray.count
            } else {
                return 1
            }
        }
        else if collectionView == wantToCollectionView {
            if wantToInfoArray.count > 0 {
                return wantToInfoArray.count
            } else {
                return 1
            }
        }
        else {
            if continueReadInfoArray.count > 0 {
                return continueReadInfoArray.count
            } else {
                return 1
            }
        }
        
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        
        if collectionView == readCollectionView {
            
            if bookInfoArray.count > 0 {
                
                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ViewControllerIds.BooksCollectionCell, for: indexPath) as! BooksCollectionViewCell
                
                let currentObj = bookInfoArray[indexPath.item]
                
                cell.imgBookCover.sd_setImage(with: URL(string: currentObj.cover_photo!), placeholderImage: UIImage(named: "defaultBookImage"))
                cell.lblBookName.text = currentObj.name
                cell.lblAuthorName.text = currentObj.author_name
                cell.ratingView.text = String(format: "%.1f", "\(Float((currentObj.rating!)))")
                let strReview = " \((currentObj.review_count)!) \((localizedTextFor(key: GeneralText.ReviewsTitle.rawValue))) "
                cell.btnReviews.setTitle(strReview, for: .normal)
                
                cell.btnReviews.tag = indexPath.item
                cell.btnReviews.addTarget(self, action: #selector(actionAllReviews(_:)), for: .touchUpInside)
                cell.btnFavUnfav.tag = indexPath.item
                cell.btnFavUnfav.addTarget(self, action: #selector(actionReadFavouriteUnfavorite(_:)), for: .touchUpInside)
                cell.btnBookSelf.tag = indexPath.item
                cell.btnBookSelf.tintColor = appThemeColor
                cell.btnBookSelf.addTarget(self, action: #selector(actionAddToShelves(_:)), for: .touchUpInside)
                
                if currentObj.is_favourite == true {
                    cell.btnFavUnfav.tintColor = appThemeColor
                } else {
                    cell.btnFavUnfav.tintColor = UIColor.gray
                }
                
                return cell
            }else {
                readCollectionView.register(UINib(nibName: ViewControllerIds.NoDataFoundCellIndetifier, bundle: nil), forCellWithReuseIdentifier: ViewControllerIds.NoDataFoundCellIndetifier)
                
                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ViewControllerIds.NoDataFoundCellIndetifier, for: indexPath) as! NoDataCollectionViewCell
                cell.lblNoDataFound.text = localizedTextFor(key: NoDataFoundScene.NoBookFound.rawValue)
                cell.lblNoDataFound.textColor = UIColor.white
                return cell
            }
            
        }
        else if collectionView == wantToCollectionView {
            
            if wantToInfoArray.count > 0 {
                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ViewControllerIds.BooksCollectionCell, for: indexPath) as! BooksCollectionViewCell
                
                let currentObj = wantToInfoArray[indexPath.item]
                
                cell.imgBookCover.sd_setImage(with: URL(string: currentObj.cover_photo!), placeholderImage: UIImage(named: "defaultBookImage"))
                cell.lblBookName.text = currentObj.name
                cell.lblAuthorName.text = currentObj.author_name
                cell.ratingView.text = String(format: "%.1f", "\(Float((currentObj.rating!)))")
                let strReview = " \((currentObj.review_count)!) \((localizedTextFor(key: GeneralText.ReviewsTitle.rawValue))) "
                cell.btnReviews.setTitle(strReview, for: .normal)
                
                cell.btnReviews.tag = indexPath.item
                cell.btnReviews.addTarget(self, action: #selector(actionAllReviews(_:)), for: .touchUpInside)
                cell.btnFavUnfav.tag = indexPath.item
                cell.btnFavUnfav.addTarget(self, action: #selector(actionWantToFavouriteUnfavorite(_:)), for: .touchUpInside)
                cell.btnBookSelf.tag = indexPath.item
                cell.btnBookSelf.tintColor = appThemeColor
                cell.btnBookSelf.addTarget(self, action: #selector(actionWantToAddToShelves(_:)), for: .touchUpInside)
                
                if currentObj.is_favourite == true {
                    cell.btnFavUnfav.tintColor = appThemeColor
                } else {
                    cell.btnFavUnfav.tintColor = UIColor.gray
                }
                
                return cell
            }else {
                wantToCollectionView.register(UINib(nibName: ViewControllerIds.NoDataFoundCellIndetifier, bundle: nil), forCellWithReuseIdentifier: ViewControllerIds.NoDataFoundCellIndetifier)
                
                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ViewControllerIds.NoDataFoundCellIndetifier, for: indexPath) as! NoDataCollectionViewCell
                cell.lblNoDataFound.text = localizedTextFor(key: NoDataFoundScene.NoBookFound.rawValue)
                cell.lblNoDataFound.textColor = UIColor.white
                return cell
            }
            
        }
        else {
            
            if continueReadInfoArray.count > 0 {
                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ViewControllerIds.BooksCollectionCell, for: indexPath) as! BooksCollectionViewCell
                
                let currentObj = continueReadInfoArray[indexPath.item]
                
                cell.imgBookCover.sd_setImage(with: URL(string: currentObj.cover_photo!), placeholderImage: UIImage(named: "defaultBookImage"))
                cell.lblBookName.text = currentObj.name
                cell.lblAuthorName.text = currentObj.author_name
                cell.ratingView.text = String(format: "%.1f", "\(Float((currentObj.rating!)))")
                let strReview = " \((currentObj.review_count)!) \((localizedTextFor(key: GeneralText.ReviewsTitle.rawValue))) "
                cell.btnReviews.setTitle(strReview, for: .normal)
                
                cell.btnReviews.tag = indexPath.item
                cell.btnReviews.addTarget(self, action: #selector(actionAllReviews(_:)), for: .touchUpInside)
                cell.btnFavUnfav.tag = indexPath.item
                cell.btnFavUnfav.addTarget(self, action: #selector(actionContinueFavouriteUnfavorite(_:)), for: .touchUpInside)
                cell.btnBookSelf.tag = indexPath.item
                cell.btnBookSelf.tintColor = appThemeColor
                
                cell.btnBookSelf.addTarget(self, action: #selector(actionContinueAddToShelves(_:)), for: .touchUpInside)
                
                if currentObj.is_favourite == true {
                    cell.btnFavUnfav.tintColor = appThemeColor
                } else {
                    cell.btnFavUnfav.tintColor = UIColor.gray
                }
                
                return cell
            }else {
                continueCollectionView.register(UINib(nibName: ViewControllerIds.NoDataFoundCellIndetifier, bundle: nil), forCellWithReuseIdentifier: ViewControllerIds.NoDataFoundCellIndetifier)
                
                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ViewControllerIds.NoDataFoundCellIndetifier, for: indexPath) as! NoDataCollectionViewCell
                cell.lblNoDataFound.text = localizedTextFor(key: NoDataFoundScene.NoBookFound.rawValue)
                cell.lblNoDataFound.textColor = UIColor.white
                return cell
            }
            
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
       
        if collectionView == wantToCollectionView {
            bookId = "\((wantToInfoArray[indexPath.item].bookId)!)"
        } else if collectionView == continueCollectionView {
            bookId = "\((continueReadInfoArray[indexPath.item].bookId)!)"
        } else {
            bookId = "\((bookInfoArray[indexPath.item].bookId)!)"
        }
        
        if bookId != nil {
            router?.navigateToBookDetail(bookId: bookId!)
        }
    }
    
    
}

extension shelvesViewController: UIScrollViewDelegate {
    
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        if scrollView == mainScrollView {
            let pageWidth = scrollView.frame.size.width
            let page = scrollView.contentOffset.x / pageWidth
            self.segmentedControl.selectedSegmentIndex = Int(page)
            
            
            if Int(page) == 0 {
                let req = shelves.Request(shelf_status: 2, openPop: false)
                interactor?.hitShelvesStatusApi(request: req)
            }
            else if Int(page) == 1 {
                let req = shelves.Request(shelf_status: 0, openPop: false)
                interactor?.hitShelvesStatusApi(request: req)
            }
            else {
                let req = shelves.Request(shelf_status: 1, openPop: false)
                interactor?.hitShelvesStatusApi(request: req)
            }
            
        }
    }
    
    func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
        if scrollView == mainScrollView {
            let pageWidth = scrollView.frame.size.width
            let page = scrollView.contentOffset.x / pageWidth
            printToConsole(item: page)
            self.segmentedControl.selectedSegmentIndex = Int(page)
            
            if Int(page) == 0 {
                let req = shelves.Request(shelf_status: 2, openPop: false)
                interactor?.hitShelvesStatusApi(request: req)
            }
            else if Int(page) == 1 {
                let req = shelves.Request(shelf_status: 0,openPop: false)
                interactor?.hitShelvesStatusApi(request: req)
            }
            else {
                let req = shelves.Request(shelf_status: 1,openPop: false)
                interactor?.hitShelvesStatusApi(request: req)
            }
            
        }
    }
}


